# Creating Components Part 1: Starting the MathSender

## Background 

Components are the lifeblood of an F' deployment. In this tutorial the components are strickly virtual, however in many deployments components will represent different piece of hardware, such as sensors and microcontrollers! 

## In this section 

## Setup

Start by creating and navigating to the directory where the components will live: 

```shell 
# In: MathProject
mkdir Components
cd Components 
```

**Component Description:** The `MathSender` is going to be an active component which will receive parameters, send parameters, log events, and send telemetry. With this is mind, use the following command to create the `MathSender` component:

```shell
# In: Components
fprime-util new --component 
```
This command will prompt you for some inputs. Answer the promts as  shown below so components matches the short description above: 

```
[INFO] Cookiecutter source: using builtin
component_name [MyComponent]: MathSender 
component_short_description [Example Component for F Prime FSW framework.]: Active component used for sending operations and operrands to the MathReceiver.
Component_namespace[Component]: MathModule
Select component_kind:
1 - active
2 - passive
3 - queued
Choose from 1, 2, 3 [1]: 1
Select enable_commands:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_telemetry:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_events:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_parameters:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
[INFO] Found CMake file at 'MathProject/project.cmake'
Add component Components/MathSender to MathProject/project.cmake at end of file (yes/no)? yes
Generate implementation files (yes/no)? yes
```


Before doing anything to the files you have just generated, try building:

```shell 
# In: MathSender
fprime-util build
```

> If you have an error here, try running `fprime-util purge` and `fprime-util generate` before building again. 

## !!!Error ^: I had to purge generate and build!!!

## Fill in the F Prime Prime Model 

Now that you have created the component, you can start working on implementing the component behavior. The first part of implementing component behavior is editting the fpp file. The fpp file will specify what goes into the autogenerated cpp and hpp files. Writing the fpp file will not implement component behavior on its own, but it will generate templates for most of what you will write in cpp and hpp files. 

In `Components/MathSender`, open `MathSender.fpp` and entirely replace its contents with the following. (Note: this is an old format of fpp files but the content is entirely correct. @TOTO).

```
module MathModule {

  @ Component for sending a math operation
  active component MathSender {

    # ----------------------------------------------------------------------
    # General ports
    # ----------------------------------------------------------------------

    @ Port for sending the operation request
    output port mathOpOut: MathOp

    @ Port for receiving the result
    async input port mathResultIn: MathResult

    # ----------------------------------------------------------------------
    # Special ports
    # ----------------------------------------------------------------------

    @ Command receive port
    command recv port cmdIn

    @ Command registration port
    command reg port cmdRegOut

    @ Command response port
    command resp port cmdResponseOut

    @ Event port
    event port eventOut

    @ Telemetry port
    telemetry port tlmOut

    @ Text event port
    text event port textEventOut

    @ Time get port
    time get port timeGetOut

    # ----------------------------------------------------------------------
    # Commands
    # ----------------------------------------------------------------------

    @ Do a math operation
    async command DO_MATH(
                           val1: F32 @< The first operand
                           op: MathOp @< The operation
                           val2: F32 @< The second operand
                         )

    # ----------------------------------------------------------------------
    # Events
    # ----------------------------------------------------------------------

    @ Math command received
    event COMMAND_RECV(
                        val1: F32 @< The first operand
                        op: MathOp @< The operation
                        val2: F32 @< The second operand
                      ) \
      severity activity low \
      format "Math command received: {f} {} {f}"

    @ Received math result
    event RESULT(
                  result: F32 @< The math result
                ) \
      severity activity high \
      format "Math result is {f}"

    # ----------------------------------------------------------------------
    # Telemetry
    # ----------------------------------------------------------------------

    @ The first value
    telemetry VAL1: F32

    @ The operation
    telemetry OP: MathOp

    @ The second value
    telemetry VAL2: F32

    @ The result
    telemetry RESULT: F32

  }

}
```

**About this Component:** 
This code defines component `MathSender`. The component is **active**, which means it has its
own thread.

Inside the definition of the `MathSender` component are
several specifiers. We have divided the specifiers into five groups:

1. **General ports:** These are user-defined ports for
application-specific functions.
There are two general ports: an output port `mathOpOut`
of type `MathOp` and an input port `mathResultIn` of
type `MathResult`.
Notice that these port specifiers use the ports that
we defined <a href="#ports">above</a>.
The input port is **asynchronous**.
This means that invoking the port (i.e., sending
data on the port) puts a message on a queue.
The handler runs later, on the thread of this component.

2. **Special ports:** These are ports that have a special
meaning in F Prime.
There are ports for registering commands with the dispatcher,
receiving commands, sending command responses, emitting
event reports, emitting telemetry, and getting the time.

3. **Commands:** These are commands sent from the ground
or from a sequencer and dispatched to this component.
There is one command `DO_MATH` for doing a math operation.
The command is asynchronous.
This means that when the command arrives, it goes on a queue
and its handler is later run on the thread of this component.

4. **Events:** These are event reports that this component
can emit.
There are two event reports, one for receiving a command
and one for receiving a result.

5. **Telemetry:** These are **channels** that define telemetry
points that the this component can emit.
There are four telemetry channels: three for the arguments
to the last command received and one for the last
result received.

> For more information on defining components, see
[_The FPP User's Guide_](https://fprime-community.github.io/fpp/fpp-users-guide.html#Defining-Components).


## Generate the Implementation Files

Now you have written the F Prime Prime code for the component, but the cpp and hpp files do not yet reflect the changes you have made to the fpp file. To get the cpp and hpp to reflect the specs you have set fourth in the fpp, you need to use the implement command as shown below: 

```shell
# In: MathSender
fprime-util impl 
```

Now, In `MathSender`, you will see two new files, `MathSender.cpp-template` and `MathSender.hpp-template`. The template files are the files you just generated using the fpp model. Whenever F' generates code, it creates new file with the `-template` so as to not burn down any old code. In this case, you did not write anything to the original `MathSender.cpp` or `MathSender.hpp`, so you can use a move command to replace the old code with the new code:


```shell 
# In: MathSender
mv MathSender.cpp-template MathSender.cpp
mv MathSender.hpp-template MathSender.hpp
```

Build MathSender to make sure everything worked as expected.

```shell 
# In: MathSender 
fprime-util build 
```

## Wait... Shouldn't You Add this to the Build? 

If you've been paying attention to the tutorial thus far, you might be getting some warning bells that you have not added your new component to the build. Fear not, when using `fprime-util new --component` all of the `CMakeLists.txt` and `project.cmake` was done for you! Take a look at both files to verify for yourself. 

## Summary 

In this section you have created a new, active component stub and filled in the component's fpp file. You also generated the cpp and hpp files for the fpp file you edited. You are now ready to edit the cpp file to implement the `MathSender`'s behavior. 

**Next:** [Creating Components 2](./creating-components-2.md)